{"ast":null,"code":"var _jsxFileName = \"/home/user/Desktop/CreateInput/my-app/src/component/colourWheel/ColourWheel.js\";\n// NOTES:\n// -- Array-destructuring assignment won't work w vanilla ie11; needs babel-polyfill lol\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types'; // Utils:\n\nimport { colourToRgbObj, getEffectiveRadius, calculateBounds, produceRgbShades, convertObjToString } from '../../utils/utils';\nimport hexStrings from '../../utils/hexStrings'; // Global-vars:\n\nconst fullCircle = 2 * Math.PI;\nconst quarterCircle = fullCircle / 4;\n\nclass ColourWheel extends Component {\n  constructor() {\n    super();\n    this.state = {\n      rgb: null,\n      innerWheelOpen: false,\n      centerCircleOpen: false\n    }; // Initialised just before the DOM has loaded; after constructor().\n\n    this.outerWheelBounds = null;\n    this.innerWheelBounds = null;\n    this.centerCircleBounds = null;\n    this.outerWheelRadius = null;\n    this.innerWheelRadius = null;\n    this.centerCircleRadius = null;\n    this.firstSpacerRadius = null;\n    this.secondSpacerRadius = null; // Initialised once the DOM has loaded.\n\n    this.canvasEl = null;\n    this.ctx = null; // Bindings:\n\n    this.onCanvasHover = this.onCanvasHover.bind(this);\n    this.onCanvasClick = this.onCanvasClick.bind(this);\n  } // MARK - Common:\n\n\n  getRelativeMousePos(clientX, clientY) {\n    const {\n      radius\n    } = this.props;\n    const canvasPos = this.canvasEl.getBoundingClientRect();\n    const h = radius * 2;\n    const w = radius * 2; // evtPos relative to our canvas.\n\n    const onCanvas = {\n      x: clientX - canvasPos.left,\n      y: clientY - canvasPos.top\n    }; // e is our mouse-position relative to the center of the canvasEl; using pythag\n\n    const fromCenter = Math.sqrt((onCanvas.x - w / 2) * (onCanvas.x - w / 2) + (onCanvas.y - h / 2) * (onCanvas.y - h / 2)); // This returns an object in which we have both mouse-pos relative to the canvas, as well as the true-middle.\n\n    return {\n      fromCenter,\n      onCanvas\n    };\n  }\n\n  initCanvas() {\n    const {\n      radius\n    } = this.props;\n    const width = radius * 2;\n    const height = radius * 2;\n    this.ctx.clearRect(0, 0, width, height);\n    this.drawOuterWheel();\n    this.drawSpacers();\n  } // MARK - Life-cycle methods:\n\n\n  componentWillMount() {\n    const {\n      radius,\n      lineWidth,\n      padding\n    } = this.props; // Setting effective radii:\n\n    this.outerWheelRadius = radius;\n    this.innerWheelRadius = this.outerWheelRadius - lineWidth - padding;\n    this.centerCircleRadius = this.innerWheelRadius - lineWidth - padding;\n    this.firstSpacerRadius = this.outerWheelRadius - lineWidth; // NOTE: effectiveRadius will take into account padding as lineWidth.\n\n    this.secondSpacerRadius = this.innerWheelRadius - lineWidth; // Defining our bounds-objects, exposes a .inside(e) -> boolean method:\n\n    this.outerWheelBounds = calculateBounds(radius - lineWidth, radius);\n    this.innerWheelBounds = calculateBounds(this.innerWheelRadius - lineWidth, this.innerWheelRadius);\n    this.centerCircleBounds = calculateBounds(0, this.centerCircleRadius);\n    this.firstSpacerBounds = calculateBounds(this.firstSpacerRadius - padding, this.firstSpacerRadius);\n    this.secondSpacerBounds = calculateBounds(this.secondSpacerRadius - padding, this.secondSpacerRadius);\n  }\n\n  componentDidMount() {\n    // Giving this context to our parent component.\n    this.props.onRef(this); // Initialising our canvas & context objs.\n\n    this.canvasEl = document.getElementById('colour-picker');\n    this.ctx = this.canvasEl.getContext('2d');\n\n    if (this.props.preset) {\n      const rgb = colourToRgbObj(this.props.presetColour);\n      this.setState({\n        rgb\n      }, () => {\n        this.drawOuterWheel();\n        this.drawInnerWheel();\n        this.drawCenterCircle();\n        this.drawSpacers();\n      });\n    } else {\n      this.drawOuterWheel();\n      this.drawSpacers();\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.onRef(undefined);\n  } // MARK - mouse-events:\n\n\n  onCanvasHover({\n    clientX,\n    clientY\n  }) {\n    const evt = this.getRelativeMousePos(clientX, clientY); // Cases for mouse-location:\n\n    if (this.outerWheelBounds.inside(evt.fromCenter)) {\n      this.canvasEl.style.cursor = 'crosshair';\n    } else if (this.innerWheelBounds.inside(evt.fromCenter) && this.state.innerWheelOpen) {\n      this.canvasEl.style.cursor = 'crosshair';\n    } else if (this.centerCircleBounds.inside(evt.fromCenter) && this.state.centerCircleOpen) {\n      // TODO: Have it clear on click?\n      this.canvasEl.style.cursor = 'pointer';\n    } else {\n      this.canvasEl.style.cursor = 'auto';\n    }\n  }\n\n  onCanvasClick({\n    clientX,\n    clientY\n  }) {\n    const evt = this.getRelativeMousePos(clientX, clientY); // Cases for click-events:\n\n    if (this.outerWheelBounds.inside(evt.fromCenter)) {\n      this.outerWheelClicked(evt.onCanvas);\n    } else if (this.innerWheelBounds.inside(evt.fromCenter) && this.state.innerWheelOpen) {\n      this.innerWheelClicked(evt.onCanvas);\n    }\n  } // MARK - Clicks & action methods:\n\n\n  outerWheelClicked(evtPos) {\n    // returns an rgba array of the pixel-clicked.\n    const rgbaArr = this.ctx.getImageData(evtPos.x, evtPos.y, 1, 1).data;\n    const [r, g, b] = rgbaArr;\n    const rgb = {\n      r,\n      g,\n      b\n    }; // Whether the user wants rgb-strings or rgb objects returned.\n\n    const rgbArg = convertObjToString(rgb); // TODO: Let user set different return values in props; e.g. rbg obj, string, etc.\n\n    this.props.onColourSelected(rgbArg);\n    this.setState({\n      rgb,\n      innerWheelOpen: true,\n      centerCircleOpen: true\n    }, () => {\n      this.drawInnerWheel();\n      this.drawCenterCircle();\n    });\n  }\n\n  innerWheelClicked(evtPos) {\n    const rgbaArr = this.ctx.getImageData(evtPos.x, evtPos.y, 1, 1).data;\n    const [r, g, b] = rgbaArr;\n    const rgb = {\n      r,\n      g,\n      b\n    };\n    const rgbArg = convertObjToString(rgb);\n    this.props.onColourSelected(rgbArg);\n    this.setState({\n      rgb,\n      centerCircleOpen: true\n    }, () => {\n      this.drawCenterCircle();\n    });\n  }\n\n  clear(callback = false) {\n    this.setState({\n      rgb: null,\n      innerWheelOpen: false,\n      centerCircleOpen: false\n    }, () => {\n      // Reset state & re-draw.\n      this.initCanvas();\n      if (callback) callback();\n    });\n  } // MARK - Drawing:\n\n\n  drawOuterWheel() {\n    // TODO: Draw outline; separate method.\n    const {\n      radius,\n      colours,\n      lineWidth\n    } = this.props;\n    const height = radius * 2;\n    const width = radius * 2; // This value ensures that the stroke accounts for the lineWidth provided to produce an accurately represented radius.\n\n    const effectiveRadius = getEffectiveRadius(radius, lineWidth); // Converting each colour into a relative rgb-object we can iterate through.\n\n    const rgbArr = colours.map(colour => colourToRgbObj(colour));\n    rgbArr.forEach((rgb, i) => {\n      this.ctx.beginPath(); // Creates strokes 1 / rgbArr.length of the circle circumference.\n\n      const startAngle = fullCircle / rgbArr.length * i;\n      const endAngle = fullCircle / rgbArr.length * (i + 1);\n      this.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle);\n      this.ctx.lineWidth = lineWidth; // This is the width of the innerWheel.\n      // Stroke-style changes based on the shade:\n\n      this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n      this.ctx.stroke();\n      this.ctx.closePath();\n    });\n  }\n\n  drawSpacers() {\n    if (this.props.spacers) {\n      this.drawSpacer(this.firstSpacerRadius);\n      this.drawSpacer(this.secondSpacerRadius);\n    }\n  }\n\n  drawSpacer(spacerRadius) {\n    const {\n      radius,\n      padding,\n      spacers: {\n        colour,\n        shadowColour,\n        shadowBlur\n      }\n    } = this.props;\n    const height = radius * 2;\n    const width = radius * 2;\n    const effectiveRadius = getEffectiveRadius(spacerRadius, padding);\n    this.ctx.beginPath();\n    this.ctx.arc(width / 2, height / 2, effectiveRadius, 0, fullCircle);\n    this.ctx.lineWidth = padding;\n    this.ctx.shadowColor = shadowColour;\n    this.ctx.shadowBlur = shadowBlur;\n    this.ctx.strokeStyle = colour;\n    this.ctx.stroke();\n    this.ctx.closePath(); // To reset our shadowColor for other strokes.\n\n    this.ctx.shadowColor = 'transparent';\n  }\n\n  drawInnerWheel(animationPercentage = 0) {\n    // raf setup.\n    let requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n    window.requestAnimationFrame = requestAnimationFrame;\n    const {\n      rgb: {\n        r,\n        g,\n        b\n      }\n    } = this.state;\n    const {\n      radius,\n      lineWidth,\n      shades,\n      animated\n    } = this.props;\n    const height = radius * 2;\n    const width = radius * 2;\n    const effectiveRadius = getEffectiveRadius(this.innerWheelRadius, lineWidth); // Re-initialising canvas.\n\n    this.ctx.clearRect(0, 0, width, height);\n    this.drawOuterWheel();\n    this.drawSpacers();\n    const rgbShades = produceRgbShades(r, g, b, shades); // Different functions for drawing our inner-wheel of shades.\n\n    function drawShades() {\n      rgbShades.forEach((rgb, i) => {\n        this.ctx.beginPath();\n        const startAngle = fullCircle / rgbShades.length * i + quarterCircle;\n        const endAngle = fullCircle / rgbShades.length * (i + 1) + 1 / 2 * Math.PI;\n        this.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle);\n        this.ctx.lineWidth = lineWidth; // This is the width of the innerWheel.\n        // Stroke style changes based on the shade:\n\n        this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n        this.ctx.stroke();\n        this.ctx.closePath();\n      });\n    }\n\n    function animateShades() {\n      rgbShades.forEach((rgb, i) => {\n        this.ctx.beginPath();\n        const startAngle = fullCircle / rgbShades.length * i + quarterCircle;\n        const endAngle = fullCircle / rgbShades.length * (i + 1) + 1 / 2 * Math.PI;\n        this.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle);\n        this.ctx.lineWidth = lineWidth * animationPercentage; // This is the width of the innerWheel.\n        // Stroke style changes based on the shade:\n\n        this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n        this.ctx.stroke();\n        this.ctx.closePath();\n      }); // TODO: Make this animation speed dynamic.\n\n      animationPercentage += 1 / 10; // i.e. 1 / x frames\n      // Essentially re-draws rgbShades.forEach until the animationPercentage reaches 1, i.e. 100%\n\n      if (animationPercentage < 1) requestAnimationFrame(animateShades);\n    }\n\n    animateShades = animateShades.bind(this);\n    drawShades = drawShades.bind(this);\n\n    if (animated) {\n      animateShades();\n    } else {\n      // TODO: Refactor into its own func.\n      drawShades();\n    }\n  }\n\n  drawCenterCircle() {\n    const {\n      rgb\n    } = this.state;\n    const {\n      radius\n    } = this.props;\n    const height = radius * 2;\n    const width = radius * 2;\n    this.ctx.lineWidth = 0;\n    this.ctx.beginPath();\n    this.ctx.arc(width / 2, height / 2, this.centerCircleRadius, 0, 2 * Math.PI);\n    this.ctx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n    this.ctx.fill();\n    this.ctx.lineWidth = 0.1;\n    this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n    this.ctx.stroke();\n    this.ctx.closePath();\n  }\n\n  render() {\n    const {\n      radius,\n      dynamicCursor\n    } = this.props;\n    return dynamicCursor ? /*#__PURE__*/React.createElement(\"canvas\", {\n      id: \"colour-picker\",\n      onClick: this.onCanvasClick,\n      onMouseMove: this.onCanvasHover,\n      width: `${radius * 2}px`,\n      height: `${radius * 2}px`,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 368,\n        columnNumber: 9\n      }\n    }) : /*#__PURE__*/React.createElement(\"canvas\", {\n      id: \"colour-picker\",\n      onClick: this.onCanvasClick,\n      width: `${radius * 2}px`,\n      height: `${radius * 2}px`,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 376,\n        columnNumber: 9\n      }\n    });\n  }\n\n}\n\nColourWheel.propTypes = {\n  radius: PropTypes.number.isRequired,\n  lineWidth: PropTypes.number.isRequired,\n  colours: PropTypes.array,\n  shades: PropTypes.number,\n  padding: PropTypes.number,\n  dynamicCursor: PropTypes.bool,\n  spacers: PropTypes.object,\n  onColourSelected: PropTypes.func,\n  preset: PropTypes.bool // presetColour: PropTypes.string\n\n};\nColourWheel.defaultProps = {\n  colours: hexStrings,\n  shades: 16,\n  padding: 0,\n  dynamicCursor: true,\n  preset: false,\n  animate: false\n};\nexport default ColourWheel;","map":{"version":3,"sources":["/home/user/Desktop/CreateInput/my-app/src/component/colourWheel/ColourWheel.js"],"names":["React","Component","PropTypes","colourToRgbObj","getEffectiveRadius","calculateBounds","produceRgbShades","convertObjToString","hexStrings","fullCircle","Math","PI","quarterCircle","ColourWheel","constructor","state","rgb","innerWheelOpen","centerCircleOpen","outerWheelBounds","innerWheelBounds","centerCircleBounds","outerWheelRadius","innerWheelRadius","centerCircleRadius","firstSpacerRadius","secondSpacerRadius","canvasEl","ctx","onCanvasHover","bind","onCanvasClick","getRelativeMousePos","clientX","clientY","radius","props","canvasPos","getBoundingClientRect","h","w","onCanvas","x","left","y","top","fromCenter","sqrt","initCanvas","width","height","clearRect","drawOuterWheel","drawSpacers","componentWillMount","lineWidth","padding","firstSpacerBounds","secondSpacerBounds","componentDidMount","onRef","document","getElementById","getContext","preset","presetColour","setState","drawInnerWheel","drawCenterCircle","componentWillUnmount","undefined","evt","inside","style","cursor","outerWheelClicked","innerWheelClicked","evtPos","rgbaArr","getImageData","data","r","g","b","rgbArg","onColourSelected","clear","callback","colours","effectiveRadius","rgbArr","map","colour","forEach","i","beginPath","startAngle","length","endAngle","arc","strokeStyle","stroke","closePath","spacers","drawSpacer","spacerRadius","shadowColour","shadowBlur","shadowColor","animationPercentage","requestAnimationFrame","window","mozRequestAnimationFrame","webkitRequestAnimationFrame","msRequestAnimationFrame","shades","animated","rgbShades","drawShades","animateShades","fillStyle","fill","render","dynamicCursor","propTypes","number","isRequired","array","bool","object","func","defaultProps","animate"],"mappings":"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","sourcesContent":["// NOTES:\n// -- Array-destructuring assignment won't work w vanilla ie11; needs babel-polyfill lol\n\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\n// Utils:\nimport {\n  colourToRgbObj,\n  getEffectiveRadius,\n  calculateBounds,\n  produceRgbShades,\n  convertObjToString\n} from '../../utils/utils'\nimport hexStrings from '../../utils/hexStrings'\n\n// Global-vars:\nconst fullCircle = 2 * Math.PI\nconst quarterCircle = fullCircle / 4\n\nclass ColourWheel extends Component {\n  constructor () {\n    super()\n\n    this.state = {\n      rgb: null,\n      innerWheelOpen: false,\n      centerCircleOpen: false\n    }\n\n    // Initialised just before the DOM has loaded; after constructor().\n    this.outerWheelBounds = null\n    this.innerWheelBounds = null\n    this.centerCircleBounds = null\n\n    this.outerWheelRadius = null\n    this.innerWheelRadius = null\n    this.centerCircleRadius = null\n    this.firstSpacerRadius = null\n    this.secondSpacerRadius = null\n\n    // Initialised once the DOM has loaded.\n    this.canvasEl = null\n    this.ctx = null\n\n    // Bindings:\n    this.onCanvasHover = this.onCanvasHover.bind(this)\n    this.onCanvasClick = this.onCanvasClick.bind(this)\n  }\n\n  // MARK - Common:\n  getRelativeMousePos (clientX, clientY) {\n    const { radius } = this.props\n\n    const canvasPos = this.canvasEl.getBoundingClientRect()\n    const h = radius * 2\n    const w = radius * 2\n\n    // evtPos relative to our canvas.\n    const onCanvas = {\n      x: clientX - canvasPos.left,\n      y: clientY - canvasPos.top\n    }\n\n    // e is our mouse-position relative to the center of the canvasEl; using pythag\n    const fromCenter = Math.sqrt((onCanvas.x - (w / 2)) * (onCanvas.x - (w / 2)) + (onCanvas.y - (h / 2)) * (onCanvas.y - (h / 2)))\n\n    // This returns an object in which we have both mouse-pos relative to the canvas, as well as the true-middle.\n    return {\n      fromCenter,\n      onCanvas\n    }\n  }\n\n  initCanvas () {\n    const { radius } = this.props\n\n    const width = radius * 2\n    const height = radius * 2\n\n    this.ctx.clearRect(0, 0, width, height)\n\n    this.drawOuterWheel()\n    this.drawSpacers()\n  }\n\n  // MARK - Life-cycle methods:\n  componentWillMount () {\n    const { radius, lineWidth, padding } = this.props\n\n    // Setting effective radii:\n    this.outerWheelRadius = radius\n    this.innerWheelRadius = this.outerWheelRadius - lineWidth - padding\n    this.centerCircleRadius = this.innerWheelRadius - lineWidth - padding\n    this.firstSpacerRadius = this.outerWheelRadius - lineWidth // NOTE: effectiveRadius will take into account padding as lineWidth.\n    this.secondSpacerRadius = this.innerWheelRadius - lineWidth\n\n    // Defining our bounds-objects, exposes a .inside(e) -> boolean method:\n    this.outerWheelBounds = calculateBounds(radius - lineWidth, radius)\n    this.innerWheelBounds = calculateBounds(this.innerWheelRadius - lineWidth, this.innerWheelRadius)\n    this.centerCircleBounds = calculateBounds(0, this.centerCircleRadius)\n    this.firstSpacerBounds = calculateBounds(this.firstSpacerRadius - padding, this.firstSpacerRadius)\n    this.secondSpacerBounds = calculateBounds(this.secondSpacerRadius - padding, this.secondSpacerRadius)\n  }\n\n  componentDidMount () {\n    // Giving this context to our parent component.\n    this.props.onRef(this)\n\n    // Initialising our canvas & context objs.\n    this.canvasEl = document.getElementById('colour-picker')\n    this.ctx = this.canvasEl.getContext('2d')\n\n    if (this.props.preset) {\n      const rgb = colourToRgbObj(this.props.presetColour)\n\n      this.setState({ rgb }, () => {\n        this.drawOuterWheel()\n        this.drawInnerWheel()\n        this.drawCenterCircle()\n        this.drawSpacers()\n      })\n    } else {\n      this.drawOuterWheel()\n      this.drawSpacers()\n    }\n  }\n\n  componentWillUnmount () {\n    this.props.onRef(undefined)\n  }\n\n  // MARK - mouse-events:\n  onCanvasHover ({ clientX, clientY }) {\n    const evt = this.getRelativeMousePos(clientX, clientY)\n\n    // Cases for mouse-location:\n    if (this.outerWheelBounds.inside(evt.fromCenter)) {\n      this.canvasEl.style.cursor = 'crosshair'\n    } else if (this.innerWheelBounds.inside(evt.fromCenter) && this.state.innerWheelOpen) {\n      this.canvasEl.style.cursor = 'crosshair'\n    } else if (this.centerCircleBounds.inside(evt.fromCenter) && this.state.centerCircleOpen) { // TODO: Have it clear on click?\n      this.canvasEl.style.cursor = 'pointer'\n    } else {\n      this.canvasEl.style.cursor = 'auto'\n    }\n  }\n\n  onCanvasClick ({ clientX, clientY }) {\n    const evt = this.getRelativeMousePos(clientX, clientY)\n\n    // Cases for click-events:\n    if (this.outerWheelBounds.inside(evt.fromCenter)) {\n      this.outerWheelClicked(evt.onCanvas)\n    } else if (this.innerWheelBounds.inside(evt.fromCenter) && this.state.innerWheelOpen) {\n      this.innerWheelClicked(evt.onCanvas)\n    }\n  }\n\n  // MARK - Clicks & action methods:\n  outerWheelClicked (evtPos) {\n    // returns an rgba array of the pixel-clicked.\n    const rgbaArr = this.ctx.getImageData(evtPos.x, evtPos.y, 1, 1).data\n    const [r, g, b] = rgbaArr\n\n    const rgb = { r, g, b }\n\n    // Whether the user wants rgb-strings or rgb objects returned.\n    const rgbArg = convertObjToString(rgb) // TODO: Let user set different return values in props; e.g. rbg obj, string, etc.\n\n    this.props.onColourSelected(rgbArg)\n\n    this.setState({\n      rgb,\n      innerWheelOpen: true,\n      centerCircleOpen: true\n    }, () => {\n      this.drawInnerWheel()\n      this.drawCenterCircle()\n    })\n  }\n\n  innerWheelClicked (evtPos) {\n    const rgbaArr = this.ctx.getImageData(evtPos.x, evtPos.y, 1, 1).data\n    const [r, g, b] = rgbaArr\n\n    const rgb = { r, g, b }\n\n    const rgbArg = convertObjToString(rgb)\n\n    this.props.onColourSelected(rgbArg)\n\n    this.setState({\n      rgb,\n      centerCircleOpen: true\n    }, () => {\n      this.drawCenterCircle()\n    })\n  }\n\n  clear (callback = false) {\n    this.setState({\n      rgb: null,\n      innerWheelOpen: false,\n      centerCircleOpen: false\n    }, () => {\n      // Reset state & re-draw.\n      this.initCanvas()\n      if (callback) callback()\n    })\n  }\n\n  // MARK - Drawing:\n  drawOuterWheel () {\n    // TODO: Draw outline; separate method.\n    const { radius, colours, lineWidth } = this.props\n    const height = radius * 2\n    const width = radius * 2\n\n    // This value ensures that the stroke accounts for the lineWidth provided to produce an accurately represented radius.\n    const effectiveRadius = getEffectiveRadius(radius, lineWidth)\n\n    // Converting each colour into a relative rgb-object we can iterate through.\n    const rgbArr = colours.map(colour => colourToRgbObj(colour))\n\n    rgbArr.forEach((rgb, i) => {\n      this.ctx.beginPath()\n\n      // Creates strokes 1 / rgbArr.length of the circle circumference.\n      const startAngle = (fullCircle / rgbArr.length) * i\n      const endAngle = (fullCircle / rgbArr.length) * (i + 1)\n\n      this.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle)\n      this.ctx.lineWidth = lineWidth // This is the width of the innerWheel.\n\n      // Stroke-style changes based on the shade:\n      this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n      this.ctx.stroke()\n      this.ctx.closePath()\n    })\n  }\n\n  drawSpacers () {\n    if (this.props.spacers) {\n      this.drawSpacer(this.firstSpacerRadius)\n      this.drawSpacer(this.secondSpacerRadius)\n    }\n  }\n\n  drawSpacer (spacerRadius) {\n    const { radius, padding, spacers: { colour, shadowColour, shadowBlur } } = this.props\n\n    const height = radius * 2\n    const width = radius * 2\n\n    const effectiveRadius = getEffectiveRadius(spacerRadius, padding)\n\n    this.ctx.beginPath()\n\n    this.ctx.arc(width / 2, height / 2, effectiveRadius, 0, fullCircle)\n    this.ctx.lineWidth = padding\n\n    this.ctx.shadowColor = shadowColour\n    this.ctx.shadowBlur = shadowBlur\n    this.ctx.strokeStyle = colour\n    this.ctx.stroke()\n    this.ctx.closePath()\n\n    // To reset our shadowColor for other strokes.\n    this.ctx.shadowColor = 'transparent'\n  }\n\n  drawInnerWheel (animationPercentage = 0) {\n    // raf setup.\n    let requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame\n    window.requestAnimationFrame = requestAnimationFrame\n\n    const { rgb: { r, g, b } } = this.state\n    const { radius, lineWidth, shades, animated } = this.props\n\n    const height = radius * 2\n    const width = radius * 2\n\n    const effectiveRadius = getEffectiveRadius(this.innerWheelRadius, lineWidth)\n\n    // Re-initialising canvas.\n    this.ctx.clearRect(0, 0, width, height)\n\n    this.drawOuterWheel()\n    this.drawSpacers()\n\n    const rgbShades = produceRgbShades(r, g, b, shades)\n\n    // Different functions for drawing our inner-wheel of shades.\n    function drawShades () {\n      rgbShades.forEach((rgb, i) => {\n        this.ctx.beginPath()\n\n        const startAngle = ((fullCircle / rgbShades.length) * i) + quarterCircle\n        const endAngle = ((fullCircle / rgbShades.length) * (i + 1)) + (1 / 2) * Math.PI\n\n        this.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle)\n        this.ctx.lineWidth = lineWidth // This is the width of the innerWheel.\n\n        // Stroke style changes based on the shade:\n        this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n        this.ctx.stroke()\n        this.ctx.closePath()\n      })\n    }\n\n    function animateShades () {\n      rgbShades.forEach((rgb, i) => {\n        this.ctx.beginPath()\n\n        const startAngle = ((fullCircle / rgbShades.length) * i) + quarterCircle\n        const endAngle = ((fullCircle / rgbShades.length) * (i + 1)) + (1 / 2) * Math.PI\n\n        this.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle)\n        this.ctx.lineWidth = lineWidth * animationPercentage // This is the width of the innerWheel.\n\n        // Stroke style changes based on the shade:\n        this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n        this.ctx.stroke()\n        this.ctx.closePath()\n      })\n\n      // TODO: Make this animation speed dynamic.\n      animationPercentage += (1 / 10) // i.e. 1 / x frames\n\n      // Essentially re-draws rgbShades.forEach until the animationPercentage reaches 1, i.e. 100%\n      if (animationPercentage < 1) requestAnimationFrame(animateShades)\n    }\n\n    animateShades = animateShades.bind(this)\n    drawShades = drawShades.bind(this)\n\n    if (animated) {\n      animateShades()\n    } else { // TODO: Refactor into its own func.\n      drawShades()\n    }\n  }\n\n  drawCenterCircle () {\n    const { rgb } = this.state\n    const { radius } = this.props\n\n    const height = radius * 2\n    const width = radius * 2\n    this.ctx.lineWidth = 0\n\n    this.ctx.beginPath()\n    this.ctx.arc(width / 2, height / 2, this.centerCircleRadius, 0, 2 * Math.PI)\n    this.ctx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n    this.ctx.fill()\n    this.ctx.lineWidth = 0.1\n    this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n    this.ctx.stroke()\n    this.ctx.closePath()\n  }\n\n  render () {\n    const { radius, dynamicCursor } = this.props\n\n    return (\n      dynamicCursor ? (\n        <canvas\n          id='colour-picker'\n          onClick={this.onCanvasClick}\n          onMouseMove={this.onCanvasHover}\n          width={`${radius * 2}px`}\n          height={`${radius * 2}px`}\n        />\n      ) : (\n        <canvas\n          id='colour-picker'\n          onClick={this.onCanvasClick}\n          width={`${radius * 2}px`}\n          height={`${radius * 2}px`}\n        />\n      )\n    )\n  }\n}\n\nColourWheel.propTypes = {\n  radius: PropTypes.number.isRequired,\n  lineWidth: PropTypes.number.isRequired,\n  colours: PropTypes.array,\n  shades: PropTypes.number,\n  padding: PropTypes.number,\n  dynamicCursor: PropTypes.bool,\n  spacers: PropTypes.object,\n  onColourSelected: PropTypes.func,\n  preset: PropTypes.bool\n  // presetColour: PropTypes.string\n}\n\nColourWheel.defaultProps = {\n  colours: hexStrings,\n  shades: 16,\n  padding: 0,\n  dynamicCursor: true,\n  preset: false,\n  animate: false\n}\n\nexport default ColourWheel\n"]},"metadata":{},"sourceType":"module"}